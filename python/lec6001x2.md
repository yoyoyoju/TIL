# lecture 6001x note 2

### 9 OOP
Object Oriented Programming

#### Objects
* an instance of an object
* every object has:
    * a type
    * internal data representation (primitive of composite)
        * data attibutes
        * what it is
    * procedures for interaction with the object
        * interface for interacting with object
        * methods: functions that only work with this class
        * procedural attributes
        * what it does: behavior/operations/methods
* can create new instances
* can destory objects
    * using `del`
    * or by garbage collection

#### Example of standard data objects
* `[1, 2, 3]` is of type `list`
* internal data representation: 
    * linked list. ([1|->]-[2|->]-[3|->]) : follow pointer to the next index
* how to manipulate lists 
    * L[i], ...
    * len(), min() ...
    * L.append() ...

#### create your own objects with classes
Create a class:
* define the class name
* define class attributes
```python
class Coordinate(object):       # the argument is class parent
    def __init__(self, x, y):   # special method to create an instance
        self.x = x
        self.y = y              # two data attributes for every Coordinate object

c = Coordinate(3, 4)            # create an instance of the class
```

* **instance variables** : data attributes of an instance


#### Methods
* always passes actual object as the first argument (generally refered as `self`)
* `.` operator to access any attribute
```python
class Coordinate(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def distance(self, other):
        x_diff_sq = (self.x - other.x)**2
        y_diff_sq = (self.y - other.y)**2
        return (x_diff_sq + y_diff_sq) ** 0.5

    def __str__(self):
        return "<" + str(self.x) + ", " + str(self,y) + ">"

c = Coordinate(3,4)
origin Coordinate(0, 0)
c.distance(origin)
Coordinate.distance(c, origin)      # same as above (using the class name)
isinstance(c, Coordinate)           # returns True
```
By using class name one can specify method from which class.
Useful when the class has superclass and want to use the superclass' method.


#### special operators
* `__add__(self, other)`        ->      `self + other`
* `__sub__(self, other)`        ->      `self - other`
* `__eq__(self, other)`         ->      `self == other`
* `__lt__(self,other)`          ->      `self < other`
* `__len__(self)`               ->      `len(self)`
* `__str__(self)`               ->      `print(self)`
[more](https://docs.python.org/3/reference/datamodel.html#basic-customization)


#### getters and setters
* should be used outside of class to access data attributes
* to ensure some properties
```python
def getNumer(self):
    return self.numer
```

#### Hierarchy
* parent class (superclass)
* child class (subclass)


#### class variables
* Instance Variables
    * so far what we saw
    * specific to an instance
    * created for each instance
    * within class refered as `self.variable_name`
* Class Variables
    * belong to the class
    * inside class but outside any class methods (outside `__init__`)
    * shared among all objects/ instances of that class
```python
class Rabbit(Animal):
    tag = 1             # class variable
    def __init__(self, age, parent1=None, parent2=None):
        Animal.__init__(self, age)  # use parent class' __init__
        self.parent1 = parent1
        self.parent2 = parent2
        self.rid = Rabbit.tag       # access class variable
        Rabbit.tag += 1             # change for all instances that may reference it
    def get_rid(self):              # getter method
        return str(self.rid).zfill(3)
```


### OOP example

#### example 1 - person
```python
import datetime

class Person(object):
    def __init__(self, name):
        """create a person called name"""
        self.name = name
        self.birthdat = None
        self.lastName = name.split(' ')[-1]
    
    def getLastName(self):
        """return self's last name"""
        return self.lastName

    def __str__(self):
        """return self's name"""
        return self.name

    def setBirthday(self, month, day, year):
        """sets self's birthday to birthDate"""
        self.birthday = daytime.date(year, month, day)

    def getAge(self):
        """returns self's current age in days"""
        if self.birthday == None:
            raise ValueError
        return (datetime.date.today() - self.birthday).days

    def __lt__(self, other):    # less than: used for sort
        """return True if self's name is lexicographically
           less than other's name, and False otherwise"""
        if self.lastName == other.lastName:
            return self.name < other.name
        return self.lastName < other.lastName

p1 = Person('Mark Zuckerberg')
p1.setBirthday(5, 14, 84)
p2 = Person('Drew Houston')
p2.setBirthday(3, 4, 83)

personList = [p1, p2]
personList.sort()
for e in personList:
    print(e)
```

#### example 1 - MITPerson
define MITPerson using inheritance.
```python
class MITPerson(Person):
    nextIdNum = 0   # class variable: next ID number to assign

    def __init__(self, name):
        Person.__init__(self, name):        # initialize Person attributes
        self.idNum = MITPerson.nextIdNum    # MITPerson attribute: unique ID
        MITPerson.nextIdNum += 1

    def getIdNum(self):                     # getter
        return self.idNum

    # sortgin MIT people uses their ID number, not name!
    def __lt__(self, other):
        return self.idNum < other.idNum

    def speak(self, utterance):
        return (self.getLastName() + " says: " + utterance)


m3 = MITPerson('Mark Zuckerberg') 
Person.setBirthday(m3,5,14,84) 
m2= MITPerson('Drew Houston') 
Person.setBirthday(m2,3,4,83)
m1 = MITPerson('Bill Gates')
Person.setBirthday(m1,10,28,55)
MITPersonList = [m1, m2, m3]
MITPersonList.sort()        # sort by id (not the name)

p1 = MITPerson('Eric')
p2 = MITPerson('John')
p3 = MITPerson('John')      # same name as p2 but has unique id
p4 = Person('John')         # does not have id
p1 < p2                     # True (compare using id)
p1 < p4                     # Attribute Error (p4 does not have id)
p4 < p1                     # False (compare by name)
```
`p1 < p4` uses `MITPerson` class' `__lt__` method since the expression means
`p1.__lt__(p4)`. As `p1` is `MITPerson` it uses `MITPerson` class' `__lt__` method.
`p4 < p1` is equivalent to `p1.__lt__(p4)`, so it uses `Person` class' `__lt__` method.


#### example 1 - Student and UG
* `pass` : special keyword says 'there is no expression in the body'.
```python
class Student(MITPerson):
    pass                   # no expression in the body 

class UG(Student):
    def __init__(self, name, classYear):
        MITPerson.__init__(self, name)
        self.year = classYear
    def getClass(self):
        return self.year
    def speak(self, utterance):
        return MITPerson.speak(self, " Dude, " + utterance)

class Grad(Student):
    pass

class TransferStudent(Student):
    pass

def isStudent(obj):
    return isinstance(obj,Student)
```

#### example 1 - Professor
```python
class Professor(MITPerson):
    def __init__(self, name ,department):
        MITPerson.__init__(self, name)
        self.department = department

    def speak(self, utterance):     # shadow MITPerson speak method
        new = 'In course ' + self.department + ' we say '
        return MITPerson.speak(self, new + utterance)

    def lecture(self, topic):
        return self.speak('it is obvious that ' + topic)
```

#### example 2 - GRADEBOOK
example of class with other classes within it.

```python
class Grades(object):
    """A mapping from students to a list of grades"""
    def __init__(self):
        """Create empty grade book"""
        self.students = []  # list of Student objects
        self.grades = {}    # maps idNum -> list of grades
        self.isSorted = True    # true if self.students is sorted

    def addStudent(self, student):
        """Assumes: student is of type Student
           Add student to the grade book"""
        if student in self.students:
            raise ValueError('Duplicate student')
        self.students.append(student)       # append student into the list of students
        self.grades[student.getIdNum()] = []
        self.isSorted = False

    def addGrade(self, student, grade):
        """Assumes: grade is a float
           Add grade to the list of grades for student"""
        try:
            self.grades[student.getIdNum()].append(grade)
        except KeyError:
            raise ValueError('Student not in grade book')

    def getGrades(self, student):
        """Return a list of grades for student"""
        try:
            # return copy of student's grades
            return self.grades[student.getIdNum()].[:]
        except KeyError:
            raise ValueError('Student not in grade book')

    def allStudents(self):
        """Return a list of the students in the grade book"""
        if not self.isSorted:
            self.students.sort()    # sort by idNum
            self.isSorted = True
        return self.students[:]     # return a copy

# use Grades
def gradeReport(course):
    """Assumes: course is of type grades"""
    report = [] # each element will be a student's average report str
    for s in course.allStudents():
        tot = 0.0
        numGrades = 0
        for g in course.getGrades(s):
            tot += g
            numGrades += 1
        try:
            avarage = tot/numGrades
            report.append(str(s) + '\'s mean grade is ' + str(average))
        except ZeroDivisionError:
            report.append(str(s) + ' has no grades')
    return '\n'.join(report)   # return the course's report as a string 

ug1 = UG('john', 2018)
ug2 = UG('jane', 2019)
ug3 = UG('joe', 2017)
g1 = Grad('kate')
g2 = Grad('bill')

six00 = Grades()    # an instance of the class Grades
six00.addStudent(g1)
six00.addStudent(g2)
six00.addStudent(ug2)
six00.addStudent(ug1)
six00.addStudent(ug3)

six00.addGrade(g1, 100)
six00.addGrade(g2, 90)
six00.addGrade(g2, 93)
six00.addGrade(ug2, 99)
six00.addGrade(ug2, 79)
six00.addGrade(ug2, 72)
six00.addGrade(ug1, 62)
six00.addGrade(ug1, 67)
six00.addGrade(ug1, 57)
print(gradeReport(six00))
```

It's good to use the method `allStudents()` then
access directly to the data attribute (`students`).
* It violates the data hiding aspect of an object
* it exposes internal representation.
* it is harder to maintain
* to change the class' internal representation,
the external procedures that uses it should be changed.
* by using methods, one should only change the methods within the object


#### Generators
* generator: any procedure or method with `yield`
* have a `next()` method which starts/resumes execution of the procedure.
* yield suspends execution and returns a value
* returning from a generator raises a StopIteration exception
* allows to generate each new objects as needed
* `range` was an example
Example 1
```python
def genTest():
    yield 1
    yield 2

foo = genTest()
foo.__next__()  # returns 1
foo.__next__()  # returns 2
foo.__next__()  # raise StopIteration exception

for n in genTest():
    print(n)
# prints:
# 1
# 2
```
Example 2
```python
def genFib():
    fibn_1 = 1
    fibn_2 = 0
    while Ture:
        next = fibn_1 + fibn_2
        yield next
        fibn_2 = fibn_1
        fibn_1 = next

# evaluating
fib = genFib()  # creates a generator object
# calling
fib.__next__()  # return fibonacci number in sequence
# evaluating
for n in genFib():  # infinite sequence
    print(n)
```
Example - better `allStudents` method
```python
def allStudents(self):
    if not self.isSorted:
        self.students.sort()
        self.isSorted = True
    for s in self.students:
        yield s
```



