# lecture 6001x note 2

### 9 OOP
Object Oriented Programming

#### Objects
* an instance of an object
* every object has:
    * a type
    * internal data representation (primitive of composite)
        * data attibutes
        * what it is
    * procedures for interaction with the object
        * interface for interacting with object
        * methods: functions that only work with this class
        * procedural attributes
        * what it does: behavior/operations/methods
* can create new instances
* can destory objects
    * using `del`
    * or by garbage collection

#### Example of standard data objects
* `[1, 2, 3]` is of type `list`
* internal data representation: 
    * linked list. ([1|->]-[2|->]-[3|->]) : follow pointer to the next index
* how to manipulate lists 
    * L[i], ...
    * len(), min() ...
    * L.append() ...

#### create your own objects with classes
Create a class:
* define the class name
* define class attributes
```python
class Coordinate(object):       # the argument is class parent
    def __init__(self, x, y):   # special method to create an instance
        self.x = x
        self.y = y              # two data attributes for every Coordinate object

c = Coordinate(3, 4)            # create an instance of the class
```

* **instance variables** : data attributes of an instance


#### Methods
* always passes actual object as the first argument (generally refered as `self`)
* `.` operator to access any attribute
```python
class Coordinate(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def distance(self, other):
        x_diff_sq = (self.x - other.x)**2
        y_diff_sq = (self.y - other.y)**2
        return (x_diff_sq + y_diff_sq) ** 0.5

    def __str__(self):
        return "<" + str(self.x) + ", " + str(self,y) + ">"

c = Coordinate(3,4)
origin Coordinate(0, 0)
c.distance(origin)
Coordinate.distance(c, origin)      # same as above (using the class name)
isinstance(c, Coordinate)           # returns True
```
By using class name one can specify method from which class.
Useful when the class has superclass and want to use the superclass' method.


#### special operators
* `__add__(self, other)`        ->      `self + other`
* `__sub__(self, other)`        ->      `self - other`
* `__eq__(self, other)`         ->      `self == other`
* `__lt__(self,other)`          ->      `self < other`
* `__len__(self)`               ->      `len(self)`
* `__str__(self)`               ->      `print(self)`
[more](https://docs.python.org/3/reference/datamodel.html#basic-customization)


#### getters and setters
* should be used outside of class to access data attributes
* to ensure some properties
```python
def getNumer(self):
    return self.numer
```

#### Hierarchy
* parent class (superclass)
* child class (subclass)


#### class variables
* Instance Variables
    * so far what we saw
    * specific to an instance
    * created for each instance
    * within class refered as `self.variable_name`
* Class Variables
    * belong to the class
    * inside class but outside any class methods (outside `__init__`)
    * shared among all objects/ instances of that class
```python
class Rabbit(Animal):
    tag = 1             # class variable
    def __init__(self, age, parent1=None, parent2=None):
        Animal.__init__(self, age)  # use parent class' __init__
        self.parent1 = parent1
        self.parent2 = parent2
        self.rid = Rabbit.tag       # access class variable
        Rabbit.tag += 1             # change for all instances that may reference it
    def get_rid(self):              # getter method
        return str(self.rid).zfill(3)
```


### OOP example

#### example 1 - person
```python
import datetime

class Person(object):
    def __init__(self, name):
        """create a person called name"""
        self.name = name
        self.birthdat = None
        self.lastName = name.split(' ')[-1]
    
    def getLastName(self):
        """return self's last name"""
        return self.lastName

    def __str__(self):
        """return self's name"""
        return self.name

    def setBirthday(self, month, day, year):
        """sets self's birthday to birthDate"""
        self.birthday = daytime.date(year, month, day)

    def getAge(self):
        """returns self's current age in days"""
        if self.birthday == None:
            raise ValueError
        return (datetime.date.today() - self.birthday).days

    def __lt__(self, other):    # less than: used for sort
        """return True if self's name is lexicographically
           less than other's name, and False otherwise"""
        if self.lastName == other.lastName:
            return self.name < other.name
        return self.lastName < other.lastName

p1 = Person('Mark Zuckerberg')
p1.setBirthday(5, 14, 84)
p2 = Person('Drew Houston')
p2.setBirthday(3, 4, 83)

personList = [p1, p2]
personList.sort()
for e in personList:
    print(e)
```

#### example 1 - MITPerson
define MITPerson using inheritance.
```python
class MITPerson(Person):
    nextIdNum = 0   # class variable: next ID number to assign

    def __init__(self, name):
        Person.__init__(self, name):        # initialize Person attributes
        self.idNum = MITPerson.nextIdNum    # MITPerson attribute: unique ID
        MITPerson.nextIdNum += 1

    def getIdNum(self):                     # getter
        return self.idNum

    # sortgin MIT people uses their ID number, not name!
    def __lt__(self, other):
        return self.idNum < other.idNum

    def speak(self, utterance):
        return (self.getLastName() + " says: " + utterance)


m3 = MITPerson('Mark Zuckerberg') 
Person.setBirthday(m3,5,14,84) 
m2= MITPerson('Drew Houston') 
Person.setBirthday(m2,3,4,83)
m1 = MITPerson('Bill Gates')
Person.setBirthday(m1,10,28,55)
MITPersonList = [m1, m2, m3]
MITPersonList.sort()        # sort by id (not the name)

p1 = MITPerson('Eric')
p2 = MITPerson('John')
p3 = MITPerson('John')      # same name as p2 but has unique id
p4 = Person('John')         # does not have id
p1 < p2                     # True (compare using id)
p1 < p4                     # Attribute Error (p4 does not have id)
p4 < p1                     # False (compare by name)
```
`p1 < p4` uses `MITPerson` class' `__lt__` method since the expression means
`p1.__lt__(p4)`. As `p1` is `MITPerson` it uses `MITPerson` class' `__lt__` method.
`p4 < p1` is equivalent to `p1.__lt__(p4)`, so it uses `Person` class' `__lt__` method.


#### example 1 - Student and UG
* `pass` : special keyword says 'there is no expression in the body'.
```python
class Student(MITPerson):
    pass                   # no expression in the body 

class UG(Student):
    def __init__(self, name, classYear):
        MITPerson.__init__(self, name)
        self.year = classYear
    def getClass(self):
        return self.year
    def speak(self, utterance):
        return MITPerson.speak(self, " Dude, " + utterance)

class Grad(Student):
    pass

class TransferStudent(Student):
    pass

def isStudent(obj):
    return isinstance(obj,Student)
```

#### example 1 - Professor
```python
class Professor(MITPerson):
    def __init__(self, name ,department):
        MITPerson.__init__(self, name)
        self.department = department

    def speak(self, utterance):     # shadow MITPerson speak method
        new = 'In course ' + self.department + ' we say '
        return MITPerson.speak(self, new + utterance)

    def lecture(self, topic):
        return self.speak('it is obvious that ' + topic)
```
