# from MIT lecture 6.001x

### Lecture1 intro

#### types of knowledge
* declarative knowledge: statements of fact.
* imperative knowledge: recipe or how-to.
    * sequence of simple steps
    * flow of control (when each step is exeucuted)
    * when to stop


#### basic machine architecture
* memory
* control unit
    * program counter
* arithmetic logic unit
    * do primitive ops
* input and output


#### aspects of languages
* syntax
* static semantics: syntactically valid strings have meaning
* semantics: meaning (when syntatically correct and no static semantic error)

#### python programs
* program: a sequence of definitions and commands.
    * difinitions evaluated
    * commands executed (to do something)

* objects
    * scalar (cannot be subdivided)
        * int, float, bool, NoneType
    * non-scalar (have internal structure that can be accessed)
        * str, list, tuple

* expressions: combine objects and operators
    * has a value, which has a type
    * `<object> <operator> <object>`
    * `i/j` : division, float
    * `i//j`: int divisionquotient without remainder, int
    * `i%j`: remainder when i is divided by j
    * `i**j`: i to the power of j


#### binding variables and valus
* equal sign `=`: assignment, binds name to value
* re-bind variable names using new assignment statements
    * previous value may still stored in memory but lost the handle for it.




### Lecture2 str, branching, iter

#### strings
* *immutable* : cannot be modified. (should re-bind to new object to change)
* operations on strings
    * `'ab'+'cd'`: concatenation
    * `3 * 'a'`: successive concatenation
    * `len('abc')`: length
    * `'abc'[1]`: indexing (begins with index 0)
    * `'abcd'[1:2]`: slicing([includec:excluded], [:] to copy it)


#### input output
* `print("hello", a)` or `print("hello " + str(a))`
* `num = int(input("get input and return as int"))`

#### while loop
```python
while <condition>:
    <expression>
    <expression>
```
* if `<condition>` is `True`, do all the steps inside the while code block
* check `<condition>` again
* repeat until `<condition>` is `False`
* if you use counter, it must be initialize before loop and increment it inside loop


#### for loop
```python
for <variable> in range(<some_num>):
    <expression>
    <expression>
```
* `range(start=0, stop, step=1)`: loop until `stop - 1` 


#### break
* immediately exits whatever loop it is in
* skips remaning expressions in code block
* exits only innermost loop




### Lecture3 loops, str, guess and check, approximation, bisection

#### float
* how to decimal to binary
    * `(x%2)` - the last binary bit
    * `(x//2)` = all the bits get shifted right
* how about fractions [code for this](fraction_binary.py)
    * multiply by a power of 2 big enough to convert into a whole number.
    * then convert to by ninary
    * divide by the same power of 2 (shift right)
    * if there is no integer `p` for `x*(2**p)` to be a whole number then it is an approximation
